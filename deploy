#!/bin/bash

usage() { echo "Usage: $0 <cluster-name> <beacon-node-endpoint>" 1>&2; exit 1; }

if [[ -z $1 ]]; then
  usage
  exit 1;
fi

CLUSTER_NAME=$1

# create the namespace if it does not exist
nsStatus=`kubectl get namespace $CLUSTER_NAME --no-headers --output=go-template={{.metadata.name}} 2>/dev/null`
if [ -z "$nsStatus" ]; then
    echo "Namespace ($CLUSTER_NAME) not found, creating new namespace ($CLUSTER_NAME)"
    kubectl create namespace $CLUSTER_NAME --dry-run=client -o yaml | kubectl apply -f -
fi

# set current namespace
echo "set namespace to $CLUSTER_NAME"
kubectl config set-context --current --namespace=$CLUSTER_NAME

# create vc keystore secrets
kubectl create secret generic keystore --from-file=keystore=./split_keys/keystore.json --from-file=password=./split_keys/keystore.txt

# cluster deployments
export CLUSTER_NAME=$1
export CHARON_BEACON_NODE_ENDPOINT=$2

# charon pv and pvc
echo "deploying charon pv and pvc."
eval "cat <<EOF
$(<./manifests/shared-pv/shared-pv.yaml)
EOF
" | kubectl apply -f -

# charon bootnode
echo "deploying charon bootnode."
eval "cat <<EOF
$(<./manifests/charon-bootnode/bootnode.yaml)
EOF
" | kubectl apply -f -

# charon nodes
echo "deploying charon nodes."
eval "cat <<EOF
$(<./manifests/charon-nodes/node0.yaml)
EOF
" | kubectl apply -f -
eval "cat <<EOF
$(<./manifests/charon-nodes/node1.yaml)
EOF
" | kubectl apply -f -
eval "cat <<EOF
$(<./manifests/charon-nodes/node2.yaml)
EOF
" | kubectl apply -f -

# validator clients
echo "deploying validator clients."
eval "cat <<EOF
$(<./manifests/validators/vc0-teku.yaml)
EOF
" | kubectl apply -f -
eval "cat <<EOF
$(<./manifests/validators/vc1-teku.yaml)
EOF
" | kubectl apply -f -
eval "cat <<EOF
$(<./manifests/validators/vc2-teku.yaml)
EOF
" | kubectl apply -f -

# monitoring tools
echo "deploying monitoring tools."
eval "cat <<EOF
$(<./manifests/monitoring/prometheus.yaml)
EOF
" | kubectl apply -f -
eval "cat <<EOF
$(<./manifests/monitoring/grafana.yaml)
EOF
" | kubectl apply -f -
