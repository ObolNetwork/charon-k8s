#!/bin/bash

usage() { echo "Usage: $0 <cluster-name> <beacon-node-endpoint>" 1>&2; exit 1; }

if [[ -z $1 ]]; then
  usage
  exit 1;
fi

CLUSTER_NAME=$1

# create the namespace if it does not exist
nsStatus=`kubectl get namespace $CLUSTER_NAME --no-headers --output=go-template={{.metadata.name}} 2>/dev/null`
if [ -z "$nsStatus" ]; then
    echo "Namespace ($CLUSTER_NAME) not found, creating new namespace ($CLUSTER_NAME)"
    kubectl create namespace $CLUSTER_NAME --dry-run=client -o yaml | kubectl apply -f -
fi

# set current namespace
echo "set namespace to $CLUSTER_NAME"
kubectl config set-context --current --namespace=$CLUSTER_NAME

# create vc keystore secrets
kubectl create secret generic keystore --from-file=keystore=./split_keys/keystore.json --from-file=password=./split_keys/keystore.txt

# deploy charon pvc, configmap, and bootnode
echo ">>> deploying charon pvc, configmap, and bootnode."
export CLUSTER_NAME=$1
export CHARON_BEACON_NODE_ENDPOINT=$2

eval "cat <<EOF
$(<./manifests/bootnode/charon-pvc.yaml)
EOF
" | kubectl apply -f -

eval "cat <<EOF
$(<./manifests/bootnode/charon-config.yaml)
EOF
" | kubectl apply -f -

kubectl apply -f manifests/bootnode/bootnode.yaml

# deploy charon nodes
echo ">>> deploying charon charon nodes."
kubectl apply -f manifests/nodes

# deploy monitoring stack
echo ">>> deploying monitoring stack."
kubectl apply -f manifests/monitoring
